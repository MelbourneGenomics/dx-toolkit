#!/usr/bin/env python

# Note:
#
# Certain Docker images build with newer versions of Docker may not work with the default ENTRYPOINT.
# We are tracking this issue with the docker2aci team here: https://github.com/appc/docker2aci/issues/198
# In the meanwhile, please provide your ENTRYPOINT command explicitly in your `dx-docker run` command.

"""dx-docker Run Docker images in your DNAnexus app."""

import argparse
import sys
import os
import subprocess
import pprint
import json
import multiprocessing.dummy
import tempfile
import glob
import datetime
import dateutil.parser
import dxpy.utils.printing
import dxpy
import yaml

CACHE_DIR = '/dx-docker-cache'

def shell(cmd, ignore_error=False):
    try:
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError as e:
        if ignore_error:
            return
        else:
            sys.exit(e.returncode)

def shell_suppress(cmd, ignore_error=False):
    out = ""
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        print e.output
        if ignore_error:
            pass
        else:
            raise
    return out

parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers()

def image_name_from_path(image_path):
    imagename = image_path.replace("/","-").replace(":", "-")
    return imagename.replace("quay.io-", "")

def get_aci_name(imagename):
    matching_files = glob.glob("{cachedir}/*{image}*.aci".format(cachedir=CACHE_DIR, image=imagename))
    if len(matching_files) == 0:
        return None
    elif len(matching_files) == 1:
        return matching_files[0]
    else:
        raise Exception("dx-docker cache error: Exactly one aci archive should correspond to an image name: {} found archives".format(len(matching_files)))

def extract_aci(image):
    imagename = image_name_from_path(image)
    aciname = get_aci_name(imagename)
    tmpdir = tempfile.mkdtemp()
    shell_suppress(["tar", "-xzf", aciname, "--exclude", "rootfs/dev/*", "-C", tmpdir], ignore_error=True)
    return tmpdir

parser_pull = subparsers.add_parser('pull', help="Pulls a docker image for use in DNAnexus")
parser_pull.add_argument("image", help="image name")
def pull(args):
    if not os.path.isdir(CACHE_DIR):
        shell_suppress(["mkdir", CACHE_DIR])
    os.chdir(CACHE_DIR)
    shell_suppress(["docker2aci", "docker://{image}".format(image=args.image)])
parser_pull.set_defaults(func=pull)


parser_run = subparsers.add_parser('run', help="Runs a docker image in a container")
parser_run.add_argument("-v", "--volume", help="Directory to mount inside the container. Can be supplied multiple times (e.g. -v /mnt/data:/mnt/data -v /host:/guest", action='append', default=[])
parser_run.add_argument("--entrypoint",  help="Overwrite default entry point for image")
parser_run.add_argument("-w", "--workdir",  help="Working directory", default="/")
parser_run.add_argument("-q", "--quiet",  action='store_true', help="Suppress printign of image metadata")
parser_run.add_argument("--rootfs",  help="Use directory pointed to here for rootfs instead of extracting the image (for expert use/development purposes)")
parser_run.add_argument("image", help="image name")
parser_run.add_argument("command", help="command to run within container", nargs=argparse.REMAINDER, default=[])
def run(args):
    imagename = image_name_from_path(args.image)
    aciname = get_aci_name(imagename)
    if not aciname:
        pull(parser_pull.parse_args([args.image]))

    if args.rootfs:
        tmpdir = args.rootfs
    else:
        tmpdir = extract_aci(args.image)

    with open("{tmpdir}/manifest".format(tmpdir=tmpdir, image=imagename)) as f:
        imagemeta = json.loads(f.read())

    annotations = {a['name'].split("/")[-1]: a['value'] for a in imagemeta['annotations']}
    labels = {a['name'].split("/")[-1]: a['value'] for a in imagemeta['labels']}
    if not args.quiet:
        def print_annotation(name, key, data=annotations):
            if key in data:
                sys.stderr.write(dxpy.utils.printing.BLUE(name)+"\t"+dxpy.utils.printing.YELLOW(data[key])+"\n")

        stats = {
            'size': shell_suppress(["du", "-sh", tmpdir]).split()[0]
        }

        if 'created' in annotations:
            created_time = dateutil.parser.parse(annotations['created'])
            current_time = datetime.datetime.now(dateutil.tz.tzutc())
            time_since_creation = current_time - created_time
            if (time_since_creation.days == 0 and time_since_creation.seconds < 10*60):
               human_readable_delta = "(just now)"
            else:
               human_readable_delta = "({}d {}h ago)".format(time_since_creation.days, time_since_creation.seconds/3600)
            stats['created'] = annotations['created'] + ' ' + human_readable_delta

        print_annotation("Image Repo", 'repository')
        print_annotation("Image Tag", 'version', data=labels)
        print_annotation("Image Size", 'size', data=stats)
        print_annotation("Image ID", 'imageid')
        print_annotation("Parent ID", 'parentimageid')
        print_annotation("Last Updated", 'created', data=stats)
        print_annotation("Registry", 'registryurl')
        print_annotation("ENTRYPOINT", 'entrypoint')
        print_annotation("Default CMD", 'cmd')
        sys.stderr.write("\n\n")


    vols = ["/run/shm/:/dev/shm"] + args.volume
    volume = []
    for v in vols:
       volume.append("-b")
       volume.append(v)


    entrypoint = []
    if args.entrypoint:
        entrypoint = [args.entrypoint]
    elif 'entrypoint' in annotations:
        entrypoint = json.loads(annotations['entrypoint'])

    cmd = []
    if args.command:
         cmd = args.command
    elif 'cmd' in annotations and not args.entrypoint:
         cmd = json.loads(annotations['cmd'])

    container_cmd = entrypoint + cmd

    workdir = args.workdir
    if 'workingDirectory' in imagemeta['app']:
       workdir = imagemeta['app']['workingDirectory']

    env = ["PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"]
    if 'environment' in imagemeta['app']:
        env += [var['name']+"="+var['value']  for var in imagemeta['app']['environment']]

    # TODO: implement some form of nested subprocesses to avoid quoting command array if possible
    proot_cmd =  ["proot", "-R", "{tmpdir}/rootfs".format(tmpdir=tmpdir)] + volume + ["-w", workdir, "/usr/bin/env", "-i"] + env + ["/bin/sh", "-c", " ".join(("'"+x+"'" for x in container_cmd))]
    shell(proot_cmd)
    if not args.rootfs:
        shell_suppress(["rm", "-r", tmpdir])
parser_run.set_defaults(func=run)

parser_upload = subparsers.add_parser('upload', help="Uploads a Docker image locally to a project in the DNAnexus platform")
parser_upload.add_argument("--output_path", "-o", help="Project ID and path in project to upload image to (defaults to project root)")
parser_upload.add_argument("image", help="image name")
def upload(args):
    # Create asset
    tmpdir = tempfile.mkdtemp()
    asset_path = tmpdir+"/resources/usr/bin"
    shell_suppress(["mkdir", "-p", asset_path])

    # Ensure core utilities are available on local host and record paths if needed later
    dx_path = shell_suppress(["which", "dx"]).rstrip()
    docker2aci_path = shell_suppress(["which", "docker2aci"]).rstrip()
    proot_path = shell_suppress(["which", "proot"]).rstrip()
    dxdocker_path = shell_suppress(["which", "dx-docker"]).rstrip()

    imagename = args.image.replace("/", "%").replace(":","#")
    # Create the asset configuration
    dxasset = { 'name': imagename }
    dxasset['title'] = "DNAnexus asset for Docker image "+args.image
    dxasset['description'] = dxasset['title']
    dxasset['version'] = "0.0.1"
    dxasset['distribution'] = "Ubuntu"
    dxasset['release'] = "14.04"
    dxasset['instanceType'] = "mem2_ssd1_x4"
    with open("{}/dxasset.json".format(tmpdir), "w") as f:
        f.write(json.dumps(dxasset))


    # Perform the operations to save and subsequently cache Docker image to the platform
    sys.stderr.write(dxpy.utils.printing.YELLOW("Exporting Docker image {}\n".format(args.image)))
    asset_cachedir = tmpdir+"/resources"+CACHE_DIR
    shell_suppress(["mkdir", "-p", asset_cachedir])
    shell(["docker", "save", "-o", tmpdir+"/image.docker.tgz", args.image])
    os.chdir(asset_cachedir)
    shell(["docker2aci", tmpdir+"/image.docker.tgz"])

    project_name = ""
    project_path = ""
    if args.output_path:
        if ":" in args.output_path:
            project_name, project_path = args.output_path.split(":")
            destpath = args.output_path + imagename
        else:
            project_name = dxpy.PROJECT_CONTEXT_ID
            project_path = args.output_path
            destpath = project_name + ":" + args.output_path + imagename
    else:
        project_name = dxpy.PROJECT_CONTEXT_ID
        project_path = ""
        destpath = project_name + ":" + imagename

    sys.stderr.write(dxpy.utils.printing.YELLOW("Building DNAnexus asset for {}\n".format(args.image)))
    #shell_suppress(["dx", "build_asset", tmpdir, "-d", destpath])
    #shell_suppress(["dx", "mv", destpath, project_name + ":" + project_path +  imagename.replace("#", "\\:").replace("%", "\\/")])
    escaped_image_name = args.image.replace("/","\\/").replace(":", "\\:")
    image_tarball = imagename+".tar.gz"
    shell_suppress(["tar", "--transform", "s|{}/resources||".format(tmpdir), "-Pczf",
	            image_tarball, tmpdir+"/resources"])
    asset_tarball_id = shell_suppress(["dx", "upload", "--wait", "--brief", "--visibility", "hidden", image_tarball])
    record_name = args.image
    record_details = {"archiveFileId": {"$dnanexus_link": asset_tarball_id}}
    record_properties = {
                          "title": dxasset["title"],
                          "description": dxasset["description"],
                          "version": "0.0.1",
                          "distribution": dxasset["distribution"],
                          "release": dxasset["release"]
                        }
    asset_bundle = dxpy.new_dxrecord(name=record_name,
                                     types=["AssetBundle"], details=record_details,
                                     properties=record_properties, close=True)

    # Add a property called {"AssetBundle": record-xxx} to the hidden tarball
    asset_file = dxpy.DXFile(asset_tarball_id)
    asset_file.set_properties({"AssetBundle": asset_bundle.get_id()})


    # Print output message for successful building of asset
    if project_path == "":
        project_path = "/"
    sys.stderr.write(dxpy.utils.printing.YELLOW("Image {} successfully cached in DNAnexus platform.\n".format(args.image)))
    sys.stderr.write("To include this cached image in an application, please include the following within the runspec/assetDepends list in your dxapp.json.\n")
    sys.stderr.write("    {"+dxpy.utils.printing.BLUE("""
        "project": \"{}\",
        "folder": \"{}\",
        "name": \"{}\",
        "version": "0.0.1"
    """).format(project_name, project_path, args.image)+"}\n")

    # Remove the temporary directory
    shell_suppress(["rm", "-r", tmpdir])

parser_upload.set_defaults(func=upload)

if __name__ == "__main__":
    args = parser.parse_args()
    args.func(args)
